'use strict'

const os = require('os')
const crypto = require('crypto')
const dayjs = require('dayjs')
const url = require('url')
const ProxyAgent = require('proxy-agent')
const cst = require('../constants.js')

const interfaceType = {
  v4: {
    default: '127.0.0.1',
    family: 'IPv4'
  },
  v6: {
    default: '::1',
    family: 'IPv6'
  }
}

/**
 * Search for public network adress
 * @param {String} type the type of network interface, can be either 'v4' or 'v6'
 */
const retrieveAddress = (type) => {
  let interfce = interfaceType[type]
  let ret = interfce.default
  let interfaces = os.networkInterfaces()

  Object.keys(interfaces).forEach(function (el) {
    interfaces[el].forEach(function (el2) {
      if (!el2.internal && el2.family === interfce.family) {
        ret = el2.address
      }
    })
  })
  return ret
}

/**
 * Simple cache implementation
 *
 * @param {Object} opts cache options
 * @param {Function} opts.miss function called when a key isn't found in the cache
 */
class Cache {
  constructor (opts) {
    this._cache = {}
    this._miss = opts.miss
    this._ttl_time = opts.ttl
    this._ttl = {}

    if (opts.ttl) {
      this._worker = setInterval(this.worker.bind(this), 1000)
    }
  }

  worker () {
    let keys = Object.keys(this._ttl)
    for (let i = 0; i < keys.length; i++) {
      let key = keys[i]
      let value = this._ttl[key]
      if (dayjs().isAfter(value)) {
        delete this._cache[key]
        delete this._ttl[key]
      }
    }
  }

  /**
   * Get a value from the cache
   *
   * @param {String} key
   */
  get (key) {
    if (!key) return null
    let value = this._cache[key]
    if (value) return value

    value = this._miss(key)

    if (value) {
      this.set(key, value)
    }
    return value
  }

  /**
   * Set a value in the cache
   *
   * @param {String} key
   * @param {Mixed} value
   */
  set (key, value) {
    if (!key || !value) return false
    this._cache[key] = value
    if (this._ttl_time) {
      this._ttl[key] = dayjs().add(this._ttl_time, 'seconds')
    }
    return true
  }

  reset () {
    this._cache = null
    this._cache = {}
    this._ttl = null
    this._ttl = {}
  }
}

/**
 * StackTraceParser is used to parse callsite from stacktrace
 * and get from FS the context of the error (if available)
 *
 * @param {Cache} cache cache implementation used to query file from FS and get context
 */
class StackTraceParser {
  constructor (opts) {
    this._cache = opts.cache
    this._context_size = opts.context
  }

  isAbsolute (path) {
    if (process.platform === 'win32') {
      // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
      let splitDeviceRe = /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/
      let result = splitDeviceRe.exec(path)
      let device = result[1] || ''
      let isUnc = Boolean(device && device.charAt(1) !== ':')
      // UNC paths are always absolute
      return Boolean(result[2] || isUnc)
    } else {
      return path.charAt(0) === '/'
    }
  }

  parse (stack) {
    if (!stack || stack.length === 0) return false

    for (var i = 0, len = stack.length; i < len; i++) {
      var callsite = stack[i]

      // avoid null values
      if (typeof callsite !== 'object') continue
      if (!callsite.file_name || !callsite.line_number) continue

      var type = this.isAbsolute(callsite.file_name) || callsite.file_name[0] === '.' ? 'user' : 'core'

      // only use the callsite if its inside user space
      if (!callsite || type === 'core' || callsite.file_name.indexOf('node_modules') > -1 ||
          callsite.file_name.indexOf('vxx') > -1) {
        continue
      }

      // get the whole context (all lines) and cache them if necessary
      var context = this._cache.get(callsite.file_name)
      var source = []
      if (context && context.length > 0) {
        // get line before the call
        var preLine = callsite.line_number - this._context_size - 1
        var pre = context.slice(preLine > 0 ? preLine : 0, callsite.line_number - 1)
        if (pre && pre.length > 0) {
          pre.forEach(function (line) {
            source.push(line.replace(/\t/g, '  '))
          })
        }
        // get the line where the call has been made
        if (context[callsite.line_number - 1]) {
          source.push(context[callsite.line_number - 1].replace(/\t/g, '  ').replace('  ', '>>'))
        }
        // and get the line after the call
        var postLine = callsite.line_number + this._context_size
        var post = context.slice(callsite.line_number, postLine)
        if (post && post.length > 0) {
          post.forEach(function (line) {
            source.push(line.replace(/\t/g, '  '))
          })
        }
      }
      return {
        context: source.length > 0 ? source.join('\n') : 'cannot retrieve source context',
        callsite: [ callsite.file_name, callsite.line_number ].join(':')
      }
    }
    return false
  }

  attachContext (error) {
    if (!error) return error

    // if pmx attached callsites we can parse them to retrieve the context
    if (typeof (error.stackframes) === 'object') {
      let result = this.parse(error.stackframes)
      // no need to send it since there is already the stacktrace
      delete error.stackframes
      delete error.__error_callsites

      if (result) {
        error.callsite = result.callsite
        error.context = result.context
      }
    }
    // if the stack is here we can parse 